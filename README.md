# TCS_supervisor
A python class to represent and execute a Supervisor Control System synthesized by Ramadgeâ€“Wonham Supervisor Control Theory (TCS)

It was designed to be able to generate automata from xml files generated by [Supremica](https://supremica.org) software.
Supremica allows to export only one or multiple models into a file, to do it: 

1. Go to the analyzer and select the desired models;
2. Export it as xml;
3. Select as destiny the **files** directory.

- Remember to export Supervisors and Plant into different xml files.

### Building handlers
After exporting the xml files, it is already possible to create the handlers responsible for the translation from high-level events
to low-level commands. 
The **Generator.py** file contains examples of the forms that code can be generated. It will create a new directory named **OP** where you will be able to implement the execution code related to each event and state of the automata.

- To generate the code for only one Automata, use the following code:

```
from lib.Automaton import Automaton

G1 = Automaton('name')
G1.read_xml('Supremica_file.xml')
```

With the Automanton object created, it is possible to automatically generate the handlers for the execution EVENTS and STATES and a TRANSLATION_TABLE:
```
G1.gen_events_calls()	
G1.gen_states_calls()
G1.gen_translation_table()
```

- To generate the code related to multiple Automata:
```
from lib.Automaton import MultiAutomata

G = MultiAutomata('Plant')
G.read_xml('files/Plant.xml')
G.generate_calls()
```
If the intention is to run both, Plant and Supervisors, repeat the process for the Supervisor xml file.

### Running the State Machine
After the handlers have been created and the translation table have been filed, it is possible to run one or multiple State Machines responsible for monitoring the system execution. 

- To run only one State Machine:
```
from lib.Automaton import Automaton
from lib.StateMachine import StateMachine

G1 = Automaton('name')
G1.read_xml('Supremica_file.xml')
SM = StateMachine(G1)
SM.start()
```

- To run multiple State Machines:
```
from lib.Automaton import Automaton
from lib.StateMachine import StateMachine

G = MultiAutomata('Plant')
G.read_xml('files/Plant.xml')         # File with multiple Automata
SM = {}
for aut in G.get_automata().values():
    SM[aut.get_name()] = StateMachine(aut)

#Start all State Machines
for sm in SM.values():
    sm.start()
```

- To run only one Supervisor:
```
from lib.Automaton import Automaton
from lib.StateMachine import StateMachine

S = Automaton('Battery Monitor')
S.read_xml('files/Supervisor_file.xml')

SM = Supervisor(S)
SM.start()
```

- To run multiple Supervisors:
```
from lib.Automaton import Automaton
from lib.StateMachine import StateMachine

S = MultiAutomata('Supervisors')
S.read_xml('files/Supervisors.xml')         # File with multiple Automata
SUP = {}
for aut in S.get_automata().values():
    SUP[aut.get_name()] = Supervisor(aut)

#Start all State Machines
for sup in SUP.values():
    sup.start()
```

By now, the State Machine is running and always that an event occur it will be updated and events will be enabled or disabled as required.
To trigger an event use:
```
from OP.EVENTS import *

event_name.call()
```

### Translation of events
Events applied to the models may not directly represent low-level events, so the generated code allows to execute the translation. This translation is separated according the direction of the event.

- **Translation from inputs to events:** to implement it you can change the code of the **EventReceiver.py** file in which there is a method that transform an input into a call for the correspondent event execution (according translation_table). We suggest the creation off a Thread periodically verify inputs and apply EventReceiver() to execute the high-level event;

- **Translation events to outputs:** into **OP/EVENTS.py** write the procedure to be executed by each event into the respectively **handler** method.

### Full System:
With this repository there is an example of models and a **system_start.py** to demonstrate a full system in execution. This program launch both Plant and Supervisors, a Mission Manager (responsible for triggering a sequence of controllable events) and an Interface that allows the visialization of all Automata and the execution of controllable events and non-controllable as if it was triggered through inputs.
